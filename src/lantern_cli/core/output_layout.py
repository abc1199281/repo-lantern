"""Flat manual output layout utilities.

Centralizes numbering, filename conversion, navigation injection,
GUIDE.md generation, and backward-compat symlink creation for the
flat numbered output layout.
"""

from __future__ import annotations

import logging
from dataclasses import dataclass
from pathlib import Path
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from lantern_cli.core.architect import Plan

logger = logging.getLogger(__name__)

# Synthesis docs that appear before per-file docs.
SYNTHESIS_PREFIX: list[tuple[str, str]] = [
    ("overview", "OVERVIEW"),
    ("architecture", "ARCHITECTURE"),
    ("concepts", "CONCEPTS"),
]

# Synthesis docs that appear after all per-file docs.
SYNTHESIS_SUFFIX: list[tuple[str, str]] = [
    ("getting-started", "GETTING_STARTED"),
]

SYNTHESIS_OFFSET = len(SYNTHESIS_PREFIX)


@dataclass
class FlatFileEntry:
    """One entry in the flat numbered output."""

    number: int
    flat_name: str
    original_path: str
    kind: str  # "synthesis" or "file"
    layer: int = 0


def rel_path_to_flat_stem(rel_path: str) -> str:
    """Convert a relative path to a flat stem using ``--`` as separator.

    Example: ``"src/core/runner.py"`` -> ``"src--core--runner.py"``
    """
    return rel_path.replace("/", "--")


def compute_flat_filename(number: int, stem: str) -> str:
    """Return a zero-padded numbered filename.

    Example: ``(4, "src--core--runner.py")`` -> ``"04-src--core--runner.py.md"``
    """
    return f"{number:02d}-{stem}.md"


def compute_file_number(batch_id: int, file_index: int, plan: Plan) -> int:
    """Compute the global file number for a specific file in a batch.

    Args:
        batch_id: The batch ID containing the file.
        file_index: Zero-based index of the file within its batch.
        plan: The full analysis plan.

    Returns:
        One-based global file number (accounting for synthesis prefix offset).
    """
    count = 0
    for phase in plan.phases:
        for batch in phase.batches:
            if batch.id < batch_id:
                count += len(batch.files)
            elif batch.id == batch_id:
                return SYNTHESIS_OFFSET + count + file_index + 1
    return SYNTHESIS_OFFSET + count + file_index + 1


def _total_files_in_plan(plan: Plan) -> int:
    """Count the total number of per-file entries across all batches."""
    return sum(len(b.files) for p in plan.phases for b in p.batches)


def build_manifest(plan: Plan) -> list[FlatFileEntry]:
    """Build the complete ordered manifest of all output files.

    Returns entries in reading order: synthesis prefix, per-file docs
    (in batch execution order), synthesis suffix.
    """
    entries: list[FlatFileEntry] = []
    num = 1

    for slug, original in SYNTHESIS_PREFIX:
        entries.append(FlatFileEntry(num, compute_flat_filename(num, slug), original, "synthesis"))
        num += 1

    for phase in plan.phases:
        for batch in phase.batches:
            for file_path in batch.files:
                stem = rel_path_to_flat_stem(file_path)
                entries.append(
                    FlatFileEntry(
                        num,
                        compute_flat_filename(num, stem),
                        file_path,
                        "file",
                        layer=phase.id,
                    )
                )
                num += 1

    for slug, original in SYNTHESIS_SUFFIX:
        entries.append(FlatFileEntry(num, compute_flat_filename(num, slug), original, "synthesis"))
        num += 1

    return entries


def inject_navigation(
    content: str,
    prev_entry: FlatFileEntry | None,
    next_entry: FlatFileEntry | None,
) -> str:
    """Append prev/next navigation footer to markdown content."""
    parts: list[str] = []
    if prev_entry:
        parts.append(f"[<< {prev_entry.flat_name}](./{prev_entry.flat_name})")
    parts.append("[GUIDE](./GUIDE.md)")
    if next_entry:
        parts.append(f"[{next_entry.flat_name} >>](./{next_entry.flat_name})")

    lines = [content.rstrip(), "", "---", "", " | ".join(parts), ""]
    return "\n".join(lines)


def generate_guide_md(entries: list[FlatFileEntry], plan: Plan) -> str:
    """Generate GUIDE.md content with TOC grouped by part."""
    lines = [
        "# Reading Guide",
        "",
        "> Generated by Lantern",
        "",
        "This manual is designed to be read **in order**.",
        "Start from 01 and work your way through.",
        "",
    ]

    # Part 1: Big Picture
    lines.append("## Part I: Big Picture")
    lines.append("")
    for entry in entries:
        if entry.kind == "synthesis" and entry.original_path != "GETTING_STARTED":
            lines.append(f"- [{entry.flat_name}](./{entry.flat_name})")
    lines.append("")

    # Part 2: Code Walkthrough grouped by layer
    lines.append("## Part II: Code Walkthrough")
    lines.append("")
    current_layer: int | None = None
    for entry in entries:
        if entry.kind != "file":
            continue
        if entry.layer != current_layer:
            current_layer = entry.layer
            # Find phase learning objectives
            obj_text = ""
            for phase in plan.phases:
                if phase.id == current_layer and phase.learning_objectives:
                    obj_text = " — " + "; ".join(phase.learning_objectives)
                    break
            lines.append(f"### Layer {current_layer}{obj_text}")
            lines.append("")
        lines.append(f"- [{entry.flat_name}](./{entry.flat_name}) — `{entry.original_path}`")
    lines.append("")

    # Part 3: Get Started
    lines.append("## Part III: Get Started")
    lines.append("")
    for entry in entries:
        if entry.kind == "synthesis" and entry.original_path == "GETTING_STARTED":
            lines.append(f"- [{entry.flat_name}](./{entry.flat_name})")
    lines.append("")

    return "\n".join(lines)


def inject_navigation_all_files(flat_dir: Path, entries: list[FlatFileEntry]) -> None:
    """Inject prev/next navigation into all flat output files."""
    for i, entry in enumerate(entries):
        file_path = flat_dir / entry.flat_name
        if not file_path.exists():
            continue
        prev_entry = entries[i - 1] if i > 0 else None
        next_entry = entries[i + 1] if i < len(entries) - 1 else None
        content = file_path.read_text(encoding="utf-8")
        updated = inject_navigation(content, prev_entry, next_entry)
        file_path.write_text(updated, encoding="utf-8")


def create_backward_compat_symlinks(
    flat_dir: Path,
    entries: list[FlatFileEntry],
) -> None:
    """Create symlinks from old paths (top_down/, bottom_up/) to new flat files.

    Silently skips on platforms where symlinks are not supported.
    """
    synth_name_map = {
        "OVERVIEW": "OVERVIEW.md",
        "ARCHITECTURE": "ARCHITECTURE.md",
        "CONCEPTS": "CONCEPTS.md",
        "GETTING_STARTED": "GETTING_STARTED.md",
    }

    # top_down/ symlinks
    top_down_dir = flat_dir / "top_down"
    top_down_dir.mkdir(parents=True, exist_ok=True)

    for entry in entries:
        if entry.kind == "synthesis" and entry.original_path in synth_name_map:
            old_name = synth_name_map[entry.original_path]
            link = top_down_dir / old_name
            target = Path("..") / entry.flat_name
            try:
                if link.exists() or link.is_symlink():
                    link.unlink()
                link.symlink_to(target)
            except OSError:
                logger.warning("Could not create symlink %s -> %s", link, target)

    # bottom_up/ symlinks
    for entry in entries:
        if entry.kind != "file":
            continue
        rel = Path(entry.original_path)
        old_path = flat_dir / "bottom_up" / rel.parent / f"{rel.name}.md"
        old_path.parent.mkdir(parents=True, exist_ok=True)
        depth = len(rel.parent.parts) + 1  # +1 for "bottom_up"
        target = Path("/".join([".."] * depth)) / entry.flat_name
        try:
            if old_path.exists() or old_path.is_symlink():
                old_path.unlink()
            old_path.symlink_to(target)
        except OSError:
            logger.warning("Could not create symlink %s -> %s", old_path, target)
